/*
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.groovy.eclipse.quickfix.proposals;

import org.eclipse.jdt.core.IJavaModelMarker;

/**
 * Generates problem descriptors that represent Java or Eclipse problems. These
 * descriptors are then handled by the Groovy quick fix framework.
 * <p>
 * 
 * Note that when the Groovy problems in GroovyCompilationUnitDeclaration are
 * changed, it may potentially change the way the descriptors are generated
 * here. Ideally, the problems defined in GroovyCompilationUnitDeclaration
 * should be merged with the Groovy problem descriptors as generated by this
 * factory.
 * </p>
 * 
 * 
 */
public class GroovyProblemFactory {

	// Go to GroovyCompilationUnitDeclaration to find all Groovy problems
	// , where they are converted to Eclipse problems

	/*
	 * FIX: This is not ideal,but the actual problem ID is package-private in JDT:
	 * @see org.eclipse.jdt.core.compiler.IProblem.MissingSemiColon 
	 */
	public static final int MISSING_SEMI_COLON_PROBLEM_ID = 1610612976;

	public static final String GROOVY_MESSAGE_IDENTIFIER = "Groovy:";

	public static final String GROOVY_UNRESOLVED_TYPE_MESSAGE = GROOVY_MESSAGE_IDENTIFIER
			+ "unable to resolve class";

	// FIX: All groovy problems have the same ID. The only way
	// to distinguish between Groovy problems is by parsing the
	// problem String arguments/messages. When Groovy Problems are
	// better defined with unique problem IDs, this needs to change
	public static final int GROOVY_PROBLEM_ID = 0;

	public static final IProblemType MISSING_SEMI_COLON_TYPE = new ProblemType(
			IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER,
			MISSING_SEMI_COLON_PROBLEM_ID);

	public static final IProblemType MISSING_IMPORTS_TYPE = new ProblemType(
			IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, GROOVY_PROBLEM_ID);

	public IProblemDescriptor getProblemDescriptor(int problemID,
			String markerDescription, String[] messages) {
		IProblemType type = getProblemType(problemID, markerDescription,
				messages);
		if (type != null) {
			return new ProblemDescriptor(type, messages);
		}
		return null;
	}

	protected IProblemType getProblemType(int problemID,
			String markerDescription, String[] messages) {
		switch (problemID) {
		case MISSING_SEMI_COLON_PROBLEM_ID:
			return MISSING_SEMI_COLON_TYPE;
		case GROOVY_PROBLEM_ID:
			return getGroovyProblemType(problemID, markerDescription, messages);
		default:
			return null;
		}
	}

	protected IProblemType getGroovyProblemType(int problemID,
			String markerDescription, String[] messages) {
		if (messages == null || messages.length == 0) {
			return null;
		}

		// For now, just check the first message.
		String message = messages[0];
		if (isMissingImportMessage(message)) {
			return MISSING_IMPORTS_TYPE;
		}
		return null;

	}

	protected boolean isMissingImportMessage(String message) {
		return message != null
				&& message.contains(GROOVY_UNRESOLVED_TYPE_MESSAGE);
	}
}
